package com.github.limdingwen.SpaceCubes;

import com.github.limdingwen.SpaceCubes.BlockTypes.Block;
import com.github.limdingwen.SpaceCubes.BlockTypes.Material;
import com.github.limdingwen.SpaceCubes.Collision.BoxCollider;
import com.github.limdingwen.SpaceCubes.Collision.Collision;
import com.github.limdingwen.SpaceCubes.EntityTypes.Player.Player;
import com.github.limdingwen.SpaceCubes.Rendering.Actor;
import com.github.limdingwen.SpaceCubes.Rendering.RenderEngine;
import com.github.limdingwen.SpaceCubes.World.Chunk;
import com.github.limdingwen.SpaceCubes.World.World;

import org.lwjgl.util.vector.Vector3f;

public class Physic {	
	public static final float GRAVITY = 0.0056f;
	public static final float TERM_VELOCITY = 0.4f;
	
	public Vector3f velocity = new Vector3f();
	public Vector3f acceleration = new Vector3f();
	public Vector3f lastPosition = new Vector3f();
	
	public boolean hasGravity = true;

	// Creator (to update physics on this particular object)

	public Actor object;

	public Physic(Actor obj) {
		object = obj;
	}

	public void update() {
		// Update gravity

		if (hasGravity) acceleration.y = -GRAVITY;

		// Update velocity

		velocity.x += acceleration.x / 4 * Main.dt;
		velocity.y += acceleration.y / 4 * Main.dt;
		velocity.z += acceleration.z / 4 * Main.dt;

		// Check if terminal velocity is reached

		if (velocity.y < -TERM_VELOCITY) {
			velocity.y = -TERM_VELOCITY;
		}

		// Update collision

		boolean isGrounded = false;
		boolean collided = false;

		World world = RenderEngine.world;

		if (object instanceof Player) {
			float ix = object.translation.x;
			float iz = object.translation.z;
			
			for (int ex = -1; ex < 2; ex++) {
				for (int ez = -1; ez < 2; ez++) {
					
					Chunk chunk = world.getChunkAtBlockCoords(
							World.coordRealToBlock(new Vector3f(
									ix+ex, 0, iz+ez)));

					if (chunk != null) { // Check if chunk exists (which will return null if not)

						if (chunk.getIsLoaded()) {
							// If it is loaded
							
							for (int bx = 0; bx < World.CHUNK_LENGTH; bx++) {
								for (int by = 0; by < World.CHUNK_HEIGHT; by++) {
									for (int bz = 0; bz < World.CHUNK_LENGTH; bz++) {
										if (Material.getMaterialFromID(chunk.blocks[bx][by][bz].material, chunk.blocks[bx][by][bz].meta).collidable) {
											Block block = chunk.blocks[bx][by][bz];
											
											if (Material.getMaterialFromID(block.material, block.meta).fullCollider) {
												Vector3f trans = object.translation;

												if (Collision.isBoxColliding((BoxCollider) block.col, trans)) {
													if (velocity.y < 0) velocity.y = 0f;

													isGrounded = true;
													collided = true;
												}

												//if (block.col != null) block.col.render(GL11.GL_LINE); // TEST CODE FOR RENDERING COLLISION BOXES
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		((Player) object).grounded = isGrounded;

		if (!collided) {
			lastPosition = object.translation;
		}

		if (collided) {
			object.translation = lastPosition;
		}

		// Apply changes to object

		object.translation.x += velocity.x;
		object.translation.y += velocity.y;
		object.translation.z += velocity.z;
	}
}
