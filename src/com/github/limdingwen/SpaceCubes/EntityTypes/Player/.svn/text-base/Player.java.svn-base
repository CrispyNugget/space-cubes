package com.github.limdingwen.SpaceCubes.EntityTypes.Player;

import org.lwjgl.util.vector.Vector2f;
import org.lwjgl.util.vector.Vector3f;

import com.github.limdingwen.SpaceCubes.Main;
import com.github.limdingwen.SpaceCubes.Physic;
import com.github.limdingwen.SpaceCubes.BlockTypes.Material;
import com.github.limdingwen.SpaceCubes.EntityTypes.Entity;
import com.github.limdingwen.SpaceCubes.Events.PlayerBreakBlock;
import com.github.limdingwen.SpaceCubes.Events.PlayerJumpEvent;
import com.github.limdingwen.SpaceCubes.Events.PlayerMoveEvent;
import com.github.limdingwen.SpaceCubes.Events.PlayerPlaceBlock;
import com.github.limdingwen.SpaceCubes.Events.PlayerRotateEvent;
import com.github.limdingwen.SpaceCubes.Rendering.BlockRenderEngine;
import com.github.limdingwen.SpaceCubes.Rendering.RenderEngine;
import com.github.limdingwen.SpaceCubes.Rendering.Stage;

public class Player extends Entity implements PlayerEventListener {
	// CONSTANTS
	
	public static final float WALK_FORWARD_SPEED = 0.01f;
	public static final float WALK_SIDEWAYS_SPEED = 0.01f;
	public static final float AIR_WALK_DIVIDER = 1;
	public static final float JUMP_VELOCITY = 0.1f;
	public static final float ROTATE_SENSITIVITY = 0.25f;
	public static final int START_HEALTH = 20;
	
	public static final float FALL_DAMAGE_START = 0.001f;
	
	public static final float VOIDPOS = -64 * BlockRenderEngine.blockSize;
	
	// Physics
	
	Physic physic = new Physic(this);
	
	public boolean grounded = true;
	public int health = START_HEALTH;
	public float fell = 0;
	
	public Material inHand = Material.DIRT;
	
	public Player(Vector3f[] v, Vector3f t, Vector3f r, int g, Stage stage) {
		super(v, t, r, g, stage); // Construct entity
		
		// INIT CODE
		
		physic.hasGravity = true;
	}

	public void playerUpdate() {
		// Update physics
		
		physic.update();
		
		// Move camera
		
		Vector3f camTranslate = new Vector3f(translation.x, translation.y, translation.z);
		camTranslate.y += BlockRenderEngine.blockSize * 4;
		RenderEngine.camera.position = camTranslate;
		
		// Rotate camera
		
		RenderEngine.camera.pitch = rotation.x;
		RenderEngine.camera.yaw = rotation.y;
		RenderEngine.camera.roll = rotation.z;	
		
		// Void detection
		
		if (translation.y < VOIDPOS) {
			respawn();
		}
	}
	
	@Override
	public void playerMove(PlayerMoveEvent event) {
		Vector2f moveRaw = event.moveDirection;
		
		if (grounded) {
			if (moveRaw.x == 1) strafeRight(WALK_SIDEWAYS_SPEED * Main.dt);
			if (moveRaw.x == -1) strafeLeft(WALK_SIDEWAYS_SPEED * Main.dt);
			if (moveRaw.y == 1) walkBackwards(WALK_FORWARD_SPEED * Main.dt);
			if (moveRaw.y == -1) walkForward(WALK_FORWARD_SPEED * Main.dt);
		}
		else {
			if (moveRaw.x == 1) strafeRight(WALK_SIDEWAYS_SPEED * Main.dt / AIR_WALK_DIVIDER);
			if (moveRaw.x == -1) strafeLeft(WALK_SIDEWAYS_SPEED * Main.dt / AIR_WALK_DIVIDER);
			if (moveRaw.y == 1) walkBackwards(WALK_FORWARD_SPEED * Main.dt / AIR_WALK_DIVIDER);
			if (moveRaw.y == -1) walkForward(WALK_FORWARD_SPEED * Main.dt / AIR_WALK_DIVIDER);
		}
	}

	@Override
	public void playerRotate(PlayerRotateEvent event) {
		rotation.y += -event.moveDirection.x * ROTATE_SENSITIVITY;
		rotation.x += event.moveDirection.y * ROTATE_SENSITIVITY;
		
		// Check if rotation is too much
		
		if (rotation.x > 90) rotation.x = 90;
		if (rotation.x < -90) rotation.x = -90;
	}

	@Override
	public void playerJump(PlayerJumpEvent event) {
		if (grounded) physic.velocity.y = JUMP_VELOCITY;
	}
	
	// Player walk events
	
	//moves the camera forward relative to its current rotation (rotation.y)
	public void walkForward(float distance)
	{   
	    translation.x -= distance * (float)Math.sin(Math.toRadians(rotation.y));
	    translation.z -= distance * (float)Math.cos(Math.toRadians(rotation.y));
	}
	 
	//moves the camera backward relative to its current rotation (rotation.y)
	public void walkBackwards(float distance)
	{

	    translation.x += distance * (float)Math.sin(Math.toRadians(rotation.y));
	    translation.z += distance * (float)Math.cos(Math.toRadians(rotation.y));	
	}
	 
	//strafes the camera left relitive to its current rotation (rotation.y)
	public void strafeLeft(float distance)
	{
	    translation.x -= distance * (float)Math.sin(Math.toRadians(rotation.y+90));
	    translation.z -= distance * (float)Math.cos(Math.toRadians(rotation.y+90));
	}
	 
	//strafes the camera right relitive to its current rotation (rotation.y)
	public void strafeRight(float distance)
	{
	    translation.x -= distance * (float)Math.sin(Math.toRadians(rotation.y-90));
	    translation.z -= distance * (float)Math.cos(Math.toRadians(rotation.y-90));
	}

	@Override
	public void playerBreakBlock(PlayerBreakBlock event) {
		RenderEngine.world.changeBlockAtToRealCoord(event.blockLoc, Material.AIR, true);
	}

	@Override
	public void playerPlaceBlock(PlayerPlaceBlock event) {
		RenderEngine.world.changeBlockAtToRealCoord(event.blockLoc, event.material, false);
	}
	
	public void respawn() {
		translation = new Vector3f(
				Main.spawn.x,
				Main.spawn.y,
				Main.spawn.z);
		
		physic.velocity = new Vector3f();
	}
}
