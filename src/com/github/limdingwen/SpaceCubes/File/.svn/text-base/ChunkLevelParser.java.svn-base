/* * To change this template, choose Tools | Templates * and open the template in the editor. */package com.github.limdingwen.SpaceCubes.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.logging.Level;import java.util.logging.Logger;import com.github.limdingwen.SpaceCubes.Vector3i;import com.github.limdingwen.SpaceCubes.BlockTypes.Block;import com.github.limdingwen.SpaceCubes.World.Chunk;import com.github.limdingwen.SpaceCubes.World.World;/** * * @author wen */public class ChunkLevelParser {	@SuppressWarnings("resource")	public static Chunk parseChunk(String worldName, int x, int y) throws IOException {		Block[][][] blocks = new Block[World.CHUNK_LENGTH][World.CHUNK_HEIGHT][World.CHUNK_LENGTH];				FileInputStream chunkStream = null;				try {			chunkStream = new FileInputStream("saves/" + worldName + "/c" + x + "|" + y + ".chk");		} catch (FileNotFoundException ex) {			System.out.println("Cannot load chunk at " + x + ", " + y + ": Cannot find file!");						throw new IOException();		}				byte[] ids = new byte[World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH];		byte[] metas = new byte[World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH*2];				try {			chunkStream.read(ids, 0, World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH);		} catch (Exception ex) {			System.out.println("Unable to load ids for chunk " + x + ", " + y);						throw new IOException();		}		try {			chunkStream.read(metas, World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH, World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH);		} catch (IndexOutOfBoundsException ex) {			System.out.println("Unable to load metas for chunk " + x + ", " + y);						throw new IOException();		}		chunkStream.close();				for (int ix = 0; ix < World.CHUNK_LENGTH; ix++) {			for (int iz = 0; iz < World.CHUNK_LENGTH; iz++) {				for (int iy = 0; iy < World.CHUNK_HEIGHT; iy++) {					blocks[ix][iy][iz] = new Block(ids[iy+(ix+iz*World.CHUNK_LENGTH)*World.CHUNK_HEIGHT], 							metas[(iy+(ix+iz*World.CHUNK_LENGTH)*World.CHUNK_HEIGHT)+(World.CHUNK_HEIGHT*World.CHUNK_LENGTH*World.CHUNK_LENGTH)], new Vector3i(							ix, iy, iz));				}			}		}				// Create chunk with blocks				return new Chunk(blocks, x, y);	}		public static World parseWorld(String worldname) {		Chunk[][] chunks = new Chunk[World.WORLD_LENGTH][World.WORLD_LENGTH];				for (int ix = 0; ix < World.WORLD_LENGTH; ix++) {			for (int iz = 0; iz < World.WORLD_LENGTH; iz++) {				try {					chunks[ix][iz] = parseChunk(worldname, ix, iz);				} catch (IOException ex) {					System.out.println("Unable to parse chunk " + ix + ", " + iz);					System.out.println("Generating chunk!");										Logger.getLogger(ChunkLevelParser.class.getName()).log(Level.INFO, null, ex);										// Generate new chunk										chunks[ix][iz] = new Chunk(null, ix, iz).generate();				}			}		}				return new World().setChunks(chunks);	}}