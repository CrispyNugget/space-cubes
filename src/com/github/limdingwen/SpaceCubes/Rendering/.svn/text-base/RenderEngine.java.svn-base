package com.github.limdingwen.SpaceCubes.Rendering;

import org.lwjgl.opengl.GL11;
import org.lwjgl.util.glu.GLU;
import org.lwjgl.util.vector.Vector3f;

import com.github.limdingwen.SpaceCubes.BlockTypes.Block;
import com.github.limdingwen.SpaceCubes.BlockTypes.Material;
import com.github.limdingwen.SpaceCubes.File.ChunkLevelParser;
import com.github.limdingwen.SpaceCubes.World.Chunk;
import com.github.limdingwen.SpaceCubes.World.World;
import com.github.limdingwen.SpaceCubes.World.WorldEngine;
import java.nio.FloatBuffer;
import org.lwjgl.BufferUtils;

public class RenderEngine {
	private static Stage stage = new Stage();
	public static Camera camera = new Camera(new Vector3f(0,0,0));
	public static BlockRenderEngine blockRenderEngine = new BlockRenderEngine();
	
	public static World world;
	
	public void init() {
		float density = 0.2f;
		float fogColor[] = {
			0.7f, 
			0.7f, 
			0.7f, 
			1.0f};
		FloatBuffer fogColorBuffer = BufferUtils.createFloatBuffer(4);
		fogColorBuffer.put(fogColor);
		fogColorBuffer.flip();
		
		// Init OpenGL
		
		GL11.glMatrixMode(GL11.GL_PROJECTION);
		GLU.gluPerspective(60, 1, 0.1f, 64);
		
		GL11.glMatrixMode(GL11.GL_MODELVIEW);
		GL11.glEnable(GL11.GL_DEPTH_TEST);
		GL11.glEnable(GL11.GL_FOG);
		GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_EXP2);
		GL11.glFog(GL11.GL_FOG_COLOR, fogColorBuffer);
		GL11.glFogf(GL11.GL_FOG_DENSITY, density);
		GL11.glFogf(GL11.GL_FOG_START, 0.0f);
		GL11.glFogf(GL11.GL_FOG_END, 0.1f);
		
		System.out.println("Initalized OpenGL");
		
		// World default
		
		world = ChunkLevelParser.parseWorld("TestWorld");
		WorldEngine.loadWorldIntoMemory(world);
	}
	
	public void render() {
		GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);  // Clear background
	//	GL11.glPolygonMode(GL11.GL_FRONT_AND_BACK, GL11.GL_LINE);
		
		GL11.glLoadIdentity();
		
		// Translate to block position
		RenderEngine.camera.lookThrough();
		
		for (int ix = 0; ix < world.chunks.length; ix++) {
			for (int iz = 0; iz < world.chunks.length; iz++) {
				// For every chunk...
				
				if (world.chunks[ix][iz].getIsLoaded()) {
					// If it is loaded
					
					Chunk chunk = world.chunks[ix][iz];
					
					for (int bx = 0; bx < World.CHUNK_LENGTH; bx++) {
						for (int by = 0; by < World.CHUNK_HEIGHT; by++) {
							for (int bz = 0; bz < World.CHUNK_LENGTH; bz++) {
								// Render each block if it is not transparent
																
								if (!Material.getMaterialFromID(chunk.blocks[bx][by][bz].material, chunk.blocks[bx][by][bz].meta).transparent) {
									Block block = chunk.blocks[bx][by][bz];
									
									if (!block.comCulled) {
										blockRenderEngine.render(block);
									}
								}
							}
						}
					}
				}
			}
		}
		
		GL11.glFlush();
	}
	
	public void update() {
        
	}

	public static  Stage getStage() {
		return stage;
	}

	public static void setStage(Stage stage) {
		RenderEngine.stage = stage;
	}
}
